---
title: 打包与部署
description: 如何将 Feat 应用打包并部署到生产环境
sidebar:
    order: 99
---

import {Aside} from '@astrojs/starlight/components';
import CheckAuthorize from '../../../components/CheckAuthorize.astro'

<CheckAuthorize/>

本指南介绍如何将 Feat 应用打包为可执行文件，并使用 Docker 进行部署。

## 打包为 Fat Jar

使用 Maven 的 `maven-shade-plugin` 插件打包成包含所有依赖的可执行 jar 包。

### 配置 pom.xml

```xml title="pom.xml"
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-shade-plugin</artifactId>
            <version>3.5.0</version>
            <executions>
                <execution>
                    <phase>package</phase>
                    <goals>
                        <goal>shade</goal>
                    </goals>
                    <configuration>
                        <transformers>
                            <!-- 追加方式合并服务文件 -->
                            <transformer
                                    implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                                <resource>META-INF/services/tech.smartboot.feat.cloud.CloudService</resource>
                            </transformer>
                            <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                <mainClass>your.package.MainClass</mainClass>
                            </transformer>
                        </transformers>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

<Aside>
    请将 `your.package.MainClass` 替换为你的主类完整类名。
</Aside>

### 执行打包

```bash
mvn clean package
```

打包完成后，在 `target` 目录下会生成包含所有依赖的 jar 文件。

## Docker 部署

### 基于 JRE 的部署

适用于传统部署场景，使用 JRE 镜像运行 jar 文件。

#### 创建 Dockerfile

```dockerfile title="Dockerfile"
FROM eclipse-temurin:21.0.7_6-jre-alpine
WORKDIR /feat
COPY target/helloworld_docker*.jar helloworld.jar

EXPOSE 8080

CMD ["java", "-jar", "helloworld.jar"]
```

#### 构建并运行

```bash
# 构建镜像
docker build -t feat-docker:jre .

# 运行容器
docker run -p 8080:8080 feat-docker:jre
```

测试：`http://localhost:8080/hello`

### 构建 Native 镜像

使用 GraalVM 将应用编译为本地可执行文件，获得更快的启动速度和更低的资源消耗。

#### 创建 Dockerfile

```dockerfile title="Dockerfile"
FROM container-registry.oracle.com/graalvm/native-image:21-ol8 AS builder

COPY target/helloworld_docker*.jar helloworld.jar

# 编译为本地可执行文件
RUN native-image --no-fallback -jar helloworld.jar

# 运行阶段：使用轻量级基础镜像
FROM ubuntu:18.04
EXPOSE 8080

COPY --from=builder /app/helloworld helloworld
ENTRYPOINT ["/helloworld"]
```

#### 构建并运行

```bash
# 打包应用
mvn clean package

# 构建 Native 镜像
docker build -t feat-docker:native .

# 运行容器
docker run -p 8080:8080 feat-docker:native
```

测试：`http://localhost:8080/hello`

<Aside>
    如使用 podman，只需将命令中的 `docker` 替换为 `podman` 即可。
</Aside>

## 部署方式对比

| 部署方式 | 启动速度 | 内存占用 | 适用场景 |
|----------|----------|----------|----------|
| Fat Jar + JRE | 中等 | 中等 | 传统部署、开发测试 |
| Native 镜像 | 极快（毫秒级） | 极低 | 云原生、Serverless、微服务 |

## 完整示例

有关完整示例，请参见 [helloworld_docker 示例项目](https://gitee.com/smartboot/feat/tree/master/demo/helloworld_docker)
