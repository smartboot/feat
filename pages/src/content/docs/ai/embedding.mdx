---
title: Embedding 与向量
description: 如何使用 Feat AI 做文本向量化与典型用法
sidebar:
    order: 4
---

import { Aside } from '@astrojs/starlight/components';

Feat AI 的 **Embedding** 能力将文本转换为固定维度的向量，常用于检索、去重、聚类或作为 RAG（检索增强生成）的向量来源。本文说明如何创建嵌入模型、对单条或批量文本做向量化。

## 任务描述

- 创建 Embedding 模型并指定厂商/模型
- 对单条文本或一批文本进行向量化（embed）
- 将得到的向量用于检索、RAG 等场景（与向量库配合时需自行对接）

## 解决方案

### 创建 Embedding 模型

通过 `FeatAI.embedding(opts -> ...)` 创建，常用配置为指定模型（厂商枚举或模型名）：

```java
import tech.smartboot.feat.ai.FeatAI;
import tech.smartboot.feat.ai.embedding.EmbeddingModel;
import tech.smartboot.feat.ai.embedding.EmbeddingModelVendor;

EmbeddingModel model = FeatAI.embedding(opt -> opt
        .model(EmbeddingModelVendor.GiteeAI.bce_embedding_base_v1)
);
```

使用 **Ollama** 时，可选用 Ollama 的 Embedding 模型，例如：

```java
EmbeddingModel model = FeatAI.embedding(opt -> opt
        .model(EmbeddingModelVendor.Ollama.nomic_embed_text)
);
```

<Aside type="tip">
Gitee AI 的 Embedding 通常需要配置 `FEAT_AI_API_KEY`；Ollama 则只需本地服务可用，无需 API Key。
</Aside>

### 单条文本向量化

`embed(String)` 返回一个 `float[]`，即该文本的向量表示：

```java
float[] vector = model.embed("你好！");
System.out.println(Arrays.toString(vector));
```

### 批量文本向量化

`embed(List<String>)` 一次请求多句，返回 `List<float[]>`，顺序与输入一致：

```java
List<String> texts = Arrays.asList("Hello World", "你好");
List<float[]> vectors = model.embed(texts);
for (float[] v : vectors) {
    System.out.println(Arrays.toString(v));
}
```

批量调用有利于减少请求次数，建议在可能时使用。

### 完整示例（基于 feat-ai 测试）

下面示例基于 `feat-ai` 模块的 `EmbeddingTest`，演示 Gitee AI 与 Ollama 两种用法（JDK 8 可运行）：

```java
import tech.smartboot.feat.ai.FeatAI;
import tech.smartboot.feat.ai.embedding.EmbeddingModel;
import tech.smartboot.feat.ai.embedding.EmbeddingModelVendor;

import java.util.Arrays;
import java.util.List;

public class EmbeddingDemo {
    public static void main(String[] args) {
        // Gitee AI
        EmbeddingModel giteeModel = FeatAI.embedding(opt ->
                opt.model(EmbeddingModelVendor.GiteeAI.bce_embedding_base_v1)
        );
        float[] single = giteeModel.embed("你好！");
        System.out.println("单条: " + Arrays.toString(single));

        List<float[]> batch = giteeModel.embed(Arrays.asList("Hello World", "你好"));
        for (float[] v : batch) {
            System.out.println(Arrays.toString(v));
        }

        // Ollama
        EmbeddingModel ollamaModel = FeatAI.embedding(opt ->
                opt.model(EmbeddingModelVendor.Ollama.nomic_embed_text)
        );
        List<float[]> ollamaVectors = ollamaModel.embed(Arrays.asList("Hello World", "你好"));
        ollamaVectors.forEach(v -> System.out.println(Arrays.toString(v)));
    }
}
```

## 典型用法

- **检索 / RAG**：将文档块或问题转为向量，写入向量库（如 Chroma、Milvus）；查询时用问题向量做相似度检索，再将检索结果交给对话模型生成答案。Feat AI 提供 `ChromaVectorStore`、`MilvusVectorStore` 等，可与 Embedding 配合使用。
- **去重 / 聚类**：对文本做 embed 后，用余弦相似度等度量做相似度计算，用于去重或聚类。
- **语义搜索**：用查询向量在已有向量集合中做最近邻搜索。

向量维度与数值范围由具体模型决定，不同模型之间向量不可混用（维度可能不同）。

## 注意事项

- 使用 Gitee AI 时需设置环境变量 **`FEAT_AI_API_KEY`**。
- Ollama 需先拉取并运行对应 Embedding 模型，例如：`ollama run nomic-embed-text`。
- 批量请求时注意厂商对单次请求条数或 token 数的限制，必要时自行分批。
- 向量库的写入、索引与查询需参考各自文档；Feat AI 的向量库集成见项目内 `vector` 包。

## 相关链接

- [开始使用 Feat AI](/feat/ai/getstart/)：依赖与基础配置
- [Feat AI 简介](/feat/ai/about/)：能力概览
- 项目内：`feat-ai` 模块 `EmbeddingTest`、`EmbeddingModelVendor`、`vector` 包（Chroma、Milvus 等）
