---
title: Router 路由组件
description: Feat Router 是一个功能强大的 HTTP 请求分发器，支持多种路由匹配方式和高级功能
sidebar:
  order: 3
---

import Mermaid from '../../../components/Mermaid.astro';

# Router 路由组件

Feat中的`Router`组件是一个功能强大的HTTP请求分发器，用于将HTTP请求分发到对应的处理程序（Handler）。它是基于`NodePath`树状结构实现的，支持多种路由匹配方式，包括精确匹配、通配符匹配、路径参数匹配等。同时提供了Session管理和请求拦截等高级功能。

## Router 基础使用

Router组件提供了基本的路由匹配功能，支持以下几种匹配模式：

### 精确匹配

精确匹配是最简单的匹配方式，只有当请求路径与路由定义完全一致时才会触发处理程序。

```java
Router router = new Router();
// 精确匹配
router.route("/users", ctx -> {
    // 处理 /users 请求
    ctx.Response.write("处理用户列表".getBytes());
});
```

### 通配符匹配

使用`*`作为通配符可以匹配任意路径，适用于处理静态资源或需要匹配大量相似路径的场景。

```java
// 通配符匹配
router.route("/static/*", ctx -> {
    // 处理 /static/ 开头的所有请求
    String path = ctx.pathParam("*");
    ctx.Response.write(("访问静态资源: " + path).getBytes());
});
```

### 路径参数匹配

使用`:paramName`的形式可以捕获路径中的动态部分，并在处理程序中通过[ctx.pathParam()](file:///Users/zhengjw22mac123/IdeaProjects/feat/feat-core/src/main/java/tech/smartboot/feat/router/Context.java#L36-L38)方法获取。

```java
// 路径参数匹配
router.route("/users/:id", ctx -> {
    String userId = ctx.pathParam("id");
    // 根据用户ID处理请求
    ctx.Response.write(("用户ID: " + userId).getBytes());
});
```

## 高级功能

Router组件除了基本的路由匹配外，还提供了一些高级功能：

### Session管理

Router内置了基于Cookie的会话管理功能，可以方便地存储和获取用户状态信息。

```java
// Session使用示例
router.route("/profile", ctx -> {
    Session session = ctx.session();
    String username = session.getAttribute("username");
    // 处理用户信息
});
```

可以通过[SessionOptions](file:///Users/zhengjw22mac123/IdeaProjects/feat/feat-core/src/main/java/tech/smartboot/feat/router/SessionOptions.java#L16-L30)配置Session的行为：

```java
Router router = new Router();
// 配置Session超时时间
router.getSessionOptions().setMaxAge(30 * 60); // 30分钟
```

### HTTP方法限定

可以针对特定的HTTP方法注册路由，这样只有对应方法的请求才会被处理。

```java
// HTTP方法限定
router.route("/api/users", "POST", ctx -> {
    // 仅处理POST请求
    ctx.Response.write("创建新用户".getBytes());
});

// 也可以同时指定多个HTTP方法
router.route("/api/users", new String[]{"PUT", "PATCH"}, ctx -> {
    // 处理PUT和PATCH请求
    ctx.Response.write("更新用户信息".getBytes());
});
```

### 拦截器

拦截器允许你在请求处理前后执行一些通用逻辑，比如身份验证、日志记录等。

首先创建一个实现[Interceptor](file:///Users/zhengjw22mac123/IdeaProjects/feat/feat-core/src/main/java/tech/smartboot/feat/router/Interceptor.java#L25-L42)接口的类：

```java
public class AuthInterceptor implements Interceptor {
    @Override
    public void intercept(Context context, CompletableFuture<Void> completableFuture, Chain chain) throws Throwable {
        Session session = context.session();
        if (session.getAttribute("user") == null) {
            // 未登录，重定向到登录页
            context.Response.sendRedirect("/login");
            completableFuture.complete(null);
            return;
        }
        // 继续执行下一个拦截器或处理程序
        chain.proceed(context, completableFuture);
    }
}
```

然后将拦截器注册到Router中：

```java
Router router = new Router();
AuthInterceptor authInterceptor = new AuthInterceptor();

// 对所有路径应用拦截器
router.addInterceptor("/*", authInterceptor);

// 或者只对特定路径应用
router.addInterceptor("/admin/*", authInterceptor);
```

## 路由匹配原理

### 核心数据结构

Router使用前缀树（Trie）结构来存储路由规则，这种结构可以高效地进行路径匹配。

<Mermaid code={`
graph TD
    A[根节点 /] --> B[users]
    A --> C[static]
    B --> D[:id]
    C --> E[*]
    
    style A fill:#FFE4B5,stroke:#333
    style B fill:#E6E6FA,stroke:#333
    style C fill:#E6E6FA,stroke:#333
    style D fill:#DDA0DD,stroke:#333
    style E fill:#DDA0DD,stroke:#333
    
    classDef normal fill:#E6E6FA,stroke:#333;
    classDef param fill:#DDA0DD,stroke:#333;
    classDef root fill:#FFE4B5,stroke:#333;
`}/>

### 匹配流程

当HTTP请求到达时，Router会按照以下流程进行匹配：

1. 解析请求URL路径
2. 在前缀树中查找匹配的节点
3. 提取路径参数（如果有的话）
4. 执行匹配到的处理器

## 完整示例

以下是一个完整的使用示例：

```java
public class RouterDemo {
    public static void main(String[] args) {
        Router router = new Router();
        
        // 首页路由
        router.route("/", ctx -> {
            ctx.Response.write("欢迎来到Feat框架".getBytes());
        });
        
        // 用户相关路由
        router.route("/users/:id", ctx -> {
            String userId = ctx.pathParam("id");
            String response = "用户ID: " + userId;
            ctx.Response.write(response.getBytes());
        });
        
        // 静态资源路由
        router.route("/static/*", ctx -> {
            String path = ctx.pathParam("*");
            String response = "访问静态资源: " + path;
            ctx.Response.write(response.getBytes());
        });
        
        // 启动服务器
        Feat.httpServer().httpHandler(router).listen(8080);
    }
}
```

有关完整示例，请参见 [RouterDemo1.java](https://gitee.com/smartboot/feat/blob/master/feat-test/src/main/java/tech/smartboot/feat/demo/router/RouterDemo1.java)

## 总结

Feat中的`Router`组件不仅提供了强大的路由匹配功能，还集成了Session管理和请求拦截等高级特性。通过树状的路由匹配结构，实现了高效的请求分发。同时，其链式调用的API设计，使得路由配置更加简洁直观。开发者可以根据实际需求，灵活运用这些功能，构建功能丰富的Web应用。