---
title: Router 路由组件
description: Feat Router 是一个功能强大的 HTTP 请求分发器，支持多种路由匹配方式和高级功能
sidebar:
  order: 3
---

import Mermaid from '../../../components/Mermaid.astro';

## 主要功能

Feat中的`Router`组件是一个功能强大的HTTP请求分发器，用于将HTTP请求分发到对应的处理程序（Handler）。它是基于`NodePath`树状结构实现的，支持多种路由匹配方式，包括精确匹配、通配符匹配、路径参数匹配等。同时提供了Session管理和请求拦截等高级功能。

### 1. 基础功能

- **路由匹配**：根据请求的URI将请求分发到对应的处理程序
- **路径参数提取**：支持从路径中提取参数
- **多种匹配方式**：支持精确匹配、通配符匹配（`*`）、路径参数匹配（`:param`）等
- **默认路由**：未匹配到任何路由时，使用默认处理程序

### 2. 高级功能

- **Session管理**：提供完整的Session生命周期管理，支持创建、获取、更新和销毁Session
- **请求拦截**：支持配置拦截器，实现请求的前置和后置处理
- **灵活配置**：支持链式调用，简化路由配置

## 路由匹配原理

Router组件使用前缀树（Trie）数据结构来存储和匹配路由规则，这种设计提供了高效的路由匹配性能。

### 1. 核心数据结构

Router组件的核心是`NodePath`类，它实现了基于前缀树的路由匹配算法。支持的路由匹配模式包括：

- 精确匹配：如 `/user/profile`
- 路径参数匹配：如 `/user/:id`
- 通配符匹配：如 `/static/*`
- 后缀匹配：如 `*.html`

### 2. 匹配流程

当请求到达时，Router会根据请求路径在前缀树中查找匹配的路由处理器。匹配优先级如下：

1. 精确路径匹配（最高优先级）
2. 路径参数匹配
3. 通配符匹配（最低优先级）

## Session管理

Router组件内置了Session管理功能，基于Cookie实现，支持自动创建、维护和清理Session。

### 1. Session配置

可以通过`SessionOptions`配置Session的行为：

```java
Router router = new Router();
// 设置Session最大存活时间（秒）
router.getSessionOptions().setMaxAge(1800); // 30分钟
```

### 2. Session操作

在请求处理中可以方便地使用Session：

```java
router.route("/session/demo", ctx -> {
    // 获取或创建Session
    Session session = ctx.session();
    
    // 设置Session属性
    session.put("userId", "12345");
    
    // 获取Session属性
    String userId = (String) session.get("userId");
    
    // 手动使Session失效
    session.invalidate();
});
```

## 拦截器使用

拦截器允许在请求处理前后执行自定义逻辑，比如权限验证、日志记录等。

### 1. 创建拦截器

实现`Interceptor`接口创建自定义拦截器：

```java
public class LogInterceptor implements Interceptor {
    @Override
    public void intercept(Context ctx, Chain chain) throws Throwable {
        System.out.println("请求开始: " + ctx.Request.getRequestURI());
        try {
            chain.proceed(ctx);
        } finally {
            System.out.println("请求结束: " + ctx.Request.getRequestURI());
        }
    }
}
```

### 2. 配置拦截器

通过`addInterceptor`方法为特定路径模式配置拦截器：

```java
Router router = new Router();
// 为所有/api路径下的请求添加拦截器
router.addInterceptor("/api/*", new LogInterceptor());
```

拦截器执行流程如下：

<Mermaid code={`
    graph LR
        A[客户端请求] --> B[拦截器1前置处理]
        B --> C[拦截器2前置处理]
        C --> D[目标路由处理]
        D --> E[拦截器2后置处理]
        E --> F[拦截器1后置处理]
        F --> G[响应客户端]
`} />

## 路由配置示例

### 1. 基础路由

```java
Router router = new Router();

// 精确匹配
router.route("/user/info", ctx -> {
    ctx.Response.write("User info");
});

// 路径参数匹配
router.route("/user/:id", ctx -> {
    String id = ctx.pathParam("id");
    ctx.Response.write("User ID: " + id);
});

// 通配符匹配
router.route("/api/*", ctx -> {
    ctx.Response.write("API endpoint");
});
```

### 2. 默认路由

当没有路由匹配时，可以配置默认处理逻辑：

```java
Router router = new Router(request -> {
    // 自定义404处理逻辑
    request.getResponse().setHttpStatus(HttpStatus.NOT_FOUND);
    request.getResponse().write("Page not found");
});
```

### 3. 深层路由示例

```java
public class DeepRouterDemo {
    public static void main(String[] args) {
        Router router = new Router();

        // 1. 精确匹配（最高优先级）
        router.route("/api/v1/user/profile", ctx -> {
            ctx.Response.write("用户档案");
        });

        // 2. 路径参数匹配（次高优先级）
        router.route("/api/v1/user/:id/orders", ctx -> {
            String userId = ctx.pathParam("id");
            ctx.Response.write("用户" + userId + "的订单列表");
        });

        // 3. 多路径参数匹配
        router.route("/api/v1/user/:userId/orders/:orderId", ctx -> {
            String userId = ctx.pathParam("userId");
            String orderId = ctx.pathParam("orderId");
            ctx.Response.write("用户" + userId + "的订单" + orderId + "详情");
        });

        // 4. 通配符匹配（最低优先级）
        router.route("/api/v1/user/*", ctx -> {
            ctx.Response.write("用户相关API");
        });

        // 5. 多层通配符匹配
        router.route("/api/*/user/*/*", ctx -> {
            ctx.Response.write("通用用户API处理");
        });
    }
}
```

上述示例展示了深层路由的匹配优先级规则：

1. 精确路径匹配：完全匹配URL路径，如`/api/v1/user/profile`
2. 路径参数匹配：包含`:param`形式的参数，如`/api/v1/user/:id/orders`
3. 通配符匹配：包含`*`的路径，如`/api/v1/user/*`或`/api/*/user/*/*`

### 4. 完整示例

```java
public class RouterDemo {
    public static void main(String[] args) {
        Router router = new Router();

        // 配置Session
        router.getSessionOptions().setMaxAge(1800);

        // 添加拦截器
        router.addInterceptor("/*", new LogInterceptor());

        // 配置路由
        router.route("/", ctx -> {
            Session session = ctx.session();
            session.put("visitTime", System.currentTimeMillis());
            ctx.Response.write("Welcome!");
        });

        router.route("/user/:id", ctx -> {
            String id = ctx.pathParam("id");
            Session session = ctx.session(); // 获取Session但不创建
            if (session != null) {
                Long visitTime = (Long) session.get("visitTime");
                ctx.Response.write("User " + id + ", last visit: " + visitTime);
            } else {
                ctx.Response.write("User " + id);
            }
        });

        // 启动服务器
        Feat.httpServer()
            .httpHandler(router)
            .listen();
    }
}
```

## 总结

Feat Router组件提供了一套完整的HTTP路由解决方案，具有以下优势：

1. **高性能**：基于前缀树的路由匹配算法，提供高效的路由查找性能
2. **灵活性**：支持多种路由匹配模式，满足不同业务场景需求
3. **易用性**：链式调用API设计，简化路由配置
4. **扩展性**：支持拦截器机制，方便添加自定义处理逻辑
5. **内置功能**：集成Session管理，无需额外配置

通过合理使用Router组件，可以快速构建功能丰富、性能优良的Web应用。